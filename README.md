# Репозиторий домашних заданий по сиситемотехнике электронно вычислительных средств

## Задание #0 Деление на 3
**Рабочая дериктория /div_three**

Входы: 

- такотвый сигнал - clk
- 1 бит сигнализирующий о начале пердачи - in_data_start
- 1 бит сигнализирующий о конце передачи - in_data_finish 
- 1 линия данных - in_data

Выход:
- 1 бит сигнализирующий о возможности делить число, полученное по data на 3 - out_is_div_three


Результаты моелирования

state - состояние машины состояний

1. На вход число 129. 129 % 3 = 0

![alt text](https://github.com/4i4urin/verilog/blob/main/div_three/img/waves_129.png)

2. На вход число 128. 128 % 3 = 2

![alt text](https://github.com/4i4urin/verilog/blob/main/div_three/img/waves_128.png)

3. На вход число 136. 136 % 3 = 1

![alt text](https://github.com/4i4urin/verilog/blob/main/div_three/img/waves_136.png)

--------------------------------------------------------------------------------------------------------


## Задание #2 Комплексный умножитель
**Рабочая дериктория /complex_mult**

Задача 
Реализовать комплексный умножитель.Доступен всего один физический модуль умножения целых чисел. Входные данные поступают каждые 3 такта, размерность 8 бит, знаковые целые числа.

Входы: 

- такотвый сигнал - clk
- 2 числа вида a + bi

Выход:
- 1 число вида a + bi - произведение вхоных чисел

Основная идея:
Реализовать свой собственный умножитель без использования операции *

Получившийся модуль умножителя двух знаковых чисел за 2 такта расположен в файле **complex_mult/mult_two_cycle.v**

Результаты моделирования:

sub_res_re_1 = a1 * a2 &emsp; sub_res_re_2 = b1 * b2

sub_res_im_1 = a1 * b2 &emsp; sub_res_im_2 = a2 * b1

res_re = sub_res_re_1 - sub_res_re_2 &emsp; res_im = sub_res_im_1 + sub_res_im_2


1) При a1 = -2 &emsp; b1 = 4 &emsp; a2 = 3 &emsp; b2 = -7


![alt text](https://github.com/4i4urin/verilog/blob/main/complex_mult/img/test_1.png)


2) При a1 = -3 &emsp; b1 = 9 &emsp; a2 = 10 &emsp; b2 = 9


![alt text](https://github.com/4i4urin/verilog/blob/main/complex_mult/img/test_2.png)


--------------------------------------------------------------------------------------------------------


## Задание #2.1 Умножитель Бута
**Рабочая дериктория /booth_multiplier**

Задача 
Реализовать умножитель по алгоритму Бута

Вход
- 2 знаковых 8 битных числа

Выход 
- 1 знаковое 8 битное число - результат произведения входных

Алгоритм был взят тут

https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D1%83%D1%82%D0%B0

Результаты моделировани

num1, num2 - входные числа, res - результат произведения

![alt text](https://github.com/4i4urin/verilog/blob/main/booth_multiplier/img/result.png)


--------------------------------------------------------------------------------------------------------


## Задание #3 БИХ фильтр
**Рабочая дериктория /IIR_filter**

Задача 
Реализовать БИХ фильтр вида y(n) = a * y(n - 1) + b * x(n), где a, b - заданные коэффициенты, x - входное значение, y - выходное

Пусть a = -2, b = 3

Данные на вход поступают **каждый такт**. Операция умножения занимает **два такта**.

Вход
- 1 знаковое 16 битное число. Поступает на вход постонянно

Выход 
- 1 знаковое 16 битное число - результат вычисления y(n)

Решение:

Преобразовать формулу фильтра из вида y(n) = a * y(n - 1) + b * x(n) в 

y(n) = a^3 * y(n - 3) + a^2 * b * x(n - 2) + a * b * x(n - 1) + b * x(n)

Задерживать выход с фильтра на 3 такта, чтобы успевать вычислять a^3 * y(n - 3) (1 такт на запись y(n - 3), 2 такта на умножение)

Для вычисления понадобится реализовать 4 операции умножения, результат будет суммой умножений

Модуль умножения за два тактка /IIR_filter/mult.v

Модуль БИХ фильтра /IIR_filter/IIR_filter.v

![alt text](https://github.com/4i4urin/verilog/blob/main/IIR_filter/img/result.png)

- out - входное значение x (10 уникальных значений, затем повторяются)
- y_check - необходимые значения выхода (расичтаны в tb, по формуле фильтра из задания, после 10 повторяются)
- y_filter - полученные значения y из фильтра (задержены на два такткта, равны ожидаемым, после 10 продолжают работать по входу)

После белой линии out и y_check, повторяют свои значения, так как расчитаны только на 10 значений
 y_filter - продолжает работу, последнее значение по заданным out - до красной линии
